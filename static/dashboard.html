<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EverScan - åŠ å¯†è´§å¸ç›‘æ§ä»ªè¡¨æ¿</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .status-bar {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
        }

        .status-item {
            text-align: center;
        }

        .status-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .status-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .crypto-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .crypto-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .crypto-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .crypto-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .crypto-name {
            font-size: 1.3rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .crypto-symbol {
            background: #3498db;
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .crypto-price {
            font-size: 2rem;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .crypto-change {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .change-positive {
            color: #27ae60;
        }

        .change-negative {
            color: #e74c3c;
        }

        .crypto-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 8px;
        }

        .stat-value {
            font-weight: bold;
            color: #2c3e50;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #7f8c8d;
            margin-top: 2px;
        }

        .technical-indicators {
            margin-top: 15px;
            padding: 15px;
            background: rgba(236, 240, 241, 0.5);
            border-radius: 10px;
        }

        .indicator-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .bollinger-bands, .rsi-indicator {
            margin-bottom: 10px;
        }

        .rsi-signal {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 10px;
        }

        .rsi-normal {
            background: #95a5a6;
            color: white;
        }

        .rsi-overbought {
            background: #e74c3c;
            color: white;
        }

        .rsi-oversold {
            background: #f39c12;
            color: white;
        }

        .charts-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .chart-container {
            height: 400px;
            margin-top: 20px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: white;
            font-size: 1.2rem;
        }

        .error {
            background: rgba(231, 76, 60, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 20px;
            color: white;
            font-size: 0.9rem;
            z-index: 1000;
        }

        .connected {
            background: #27ae60;
        }

        .disconnected {
            background: #e74c3c;
        }

        @media (max-width: 768px) {
            .crypto-grid {
                grid-template-columns: 1fr;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">
        ğŸ”Œ è¿æ¥ä¸­...
    </div>

    <div class="container">
        <div class="header">
            <h1>ğŸš€ EverScan</h1>
            <p>å®æ—¶åŠ å¯†è´§å¸ç›‘æ§ä»ªè¡¨æ¿</p>
        </div>

        <div class="status-bar" id="statusBar">
            <div class="status-item">
                <div class="status-value" id="totalCoins">-</div>
                <div class="status-label">ç›‘æ§å¸ç§</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="lastUpdate">-</div>
                <div class="status-label">æœ€åæ›´æ–°</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="fearGreedIndex">-</div>
                <div class="status-label">è´ªå©ªææƒ§æŒ‡æ•°</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="cacheHits">-</div>
                <div class="status-label">ç¼“å­˜å‘½ä¸­ç‡</div>
            </div>
        </div>

        <div id="cryptoContainer" class="crypto-grid">
            <div class="loading">
                ğŸ“Š æ­£åœ¨åŠ è½½åŠ å¯†è´§å¸æ•°æ®...
            </div>
        </div>

        <div class="charts-section">
            <h2>ğŸ“ˆ ä»·æ ¼è¶‹åŠ¿å›¾è¡¨</h2>
            <div class="chart-container">
                <canvas id="priceChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        class CryptoDashboard {
            constructor() {
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 1000;
                this.priceChart = null;
                this.priceHistory = new Map();
                
                this.init();
            }

            init() {
                this.connectWebSocket();
                this.fetchInitialData();
                this.initChart();
                
                // å®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®
                setInterval(() => {
                    this.cleanupOldData();
                }, 60000); // æ¯åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡
            }

            connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                
                try {
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('ğŸ”Œ WebSocketè¿æ¥å·²å»ºç«‹');
                        this.updateConnectionStatus(true);
                        this.reconnectAttempts = 0;
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.updateCryptoData(data);
                        } catch (error) {
                            console.error('âŒ è§£æWebSocketæ•°æ®å¤±è´¥:', error);
                        }
                    };
                    
                    this.ws.onclose = () => {
                        console.log('ğŸ”Œ WebSocketè¿æ¥å·²å…³é—­');
                        this.updateConnectionStatus(false);
                        this.attemptReconnect();
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('âŒ WebSocketé”™è¯¯:', error);
                        this.updateConnectionStatus(false);
                    };
                } catch (error) {
                    console.error('âŒ åˆ›å»ºWebSocketè¿æ¥å¤±è´¥:', error);
                    this.updateConnectionStatus(false);
                }
            }

            attemptReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    console.log(`ğŸ”„ å°è¯•é‡è¿ (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                    
                    setTimeout(() => {
                        this.connectWebSocket();
                    }, this.reconnectDelay * this.reconnectAttempts);
                } else {
                    console.error('âŒ è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œåœæ­¢é‡è¿');
                    this.showError('è¿æ¥å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                }
            }

            async fetchInitialData() {
                try {
                    const response = await fetch('/api/market-data');
                    const result = await response.json();
                    
                    if (result.success && result.data) {
                        this.updateCryptoData(result.data);
                    } else {
                        throw new Error(result.error || 'è·å–æ•°æ®å¤±è´¥');
                    }
                } catch (error) {
                    console.error('âŒ è·å–åˆå§‹æ•°æ®å¤±è´¥:', error);
                    this.showError('è·å–åˆå§‹æ•°æ®å¤±è´¥: ' + error.message);
                }
                
                // è·å–è´ªå©ªææƒ§æŒ‡æ•°
                try {
                    const response = await fetch('/api/fear-greed-index');
                    const result = await response.json();
                    
                    if (result.success && result.data) {
                        this.updateFearGreedIndex(result.data);
                    }
                } catch (error) {
                    console.error('âŒ è·å–è´ªå©ªææƒ§æŒ‡æ•°å¤±è´¥:', error);
                }
                
                // è·å–ç¼“å­˜ç»Ÿè®¡
                try {
                    const response = await fetch('/api/stats');
                    const result = await response.json();
                    
                    if (result.success && result.data) {
                        this.updateStats(result.data);
                    }
                } catch (error) {
                    console.error('âŒ è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥:', error);
                }
            }

            updateCryptoData(cryptoData) {
                const container = document.getElementById('cryptoContainer');
                
                if (!Array.isArray(cryptoData) || cryptoData.length === 0) {
                    container.innerHTML = '<div class="loading">ğŸ“Š æš‚æ— æ•°æ®</div>';
                    return;
                }

                // æ›´æ–°ä»·æ ¼å†å²
                cryptoData.forEach(coin => {
                    if (!this.priceHistory.has(coin.coin_id)) {
                        this.priceHistory.set(coin.coin_id, []);
                    }
                    
                    const history = this.priceHistory.get(coin.coin_id);
                    history.push({
                        time: new Date(coin.updated_at),
                        price: coin.current_price
                    });
                    
                    // ä¿ç•™æœ€è¿‘100ä¸ªæ•°æ®ç‚¹
                    if (history.length > 100) {
                        history.shift();
                    }
                });

                container.innerHTML = cryptoData.map(coin => this.createCryptoCard(coin)).join('');
                
                // æ›´æ–°çŠ¶æ€æ 
                document.getElementById('totalCoins').textContent = cryptoData.length;
                const latestUpdate = Math.max(...cryptoData.map(c => new Date(c.updated_at)));
                document.getElementById('lastUpdate').textContent = this.formatTime(new Date(latestUpdate));
                
                // æ›´æ–°å›¾è¡¨
                this.updateChart(cryptoData);
            }

            createCryptoCard(coin) {
                const changeClass = coin.price_change_24h >= 0 ? 'change-positive' : 'change-negative';
                const changeIcon = coin.price_change_24h >= 0 ? 'ğŸ“ˆ' : 'ğŸ“‰';
                
                const rsiSignalClass = this.getRSISignalClass(coin.technical_indicators.rsi.signal);
                const rsiSignalText = this.getRSISignalText(coin.technical_indicators.rsi.signal);
                
                return `
                    <div class="crypto-card">
                        <div class="crypto-header">
                            <div class="crypto-name">${coin.name}</div>
                            <div class="crypto-symbol">${coin.symbol.toUpperCase()}</div>
                        </div>
                        
                        <div class="crypto-price">$${coin.current_price.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                        
                        <div class="crypto-change ${changeClass}">
                            ${changeIcon} ${coin.price_change_24h ? coin.price_change_24h.toFixed(2) : '0.00'}% (24h)
                        </div>
                        
                        <div class="crypto-stats">
                            <div class="stat-item">
                                <div class="stat-value">$${coin.volume_24h ? this.formatLargeNumber(coin.volume_24h) : 'N/A'}</div>
                                <div class="stat-label">24h äº¤æ˜“é‡</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value">$${coin.market_cap ? this.formatLargeNumber(coin.market_cap) : 'N/A'}</div>
                                <div class="stat-label">å¸‚å€¼</div>
                            </div>
                        </div>
                        
                        <div class="technical-indicators">
                            <div class="indicator-title">ğŸ“Š æŠ€æœ¯æŒ‡æ ‡</div>
                            
                            <div class="bollinger-bands">
                                <strong>å¸ƒæ—å¸¦:</strong><br>
                                ä¸Šè½¨: $${coin.technical_indicators.bollinger_bands.upper.toFixed(2)}<br>
                                ä¸­è½¨: $${coin.technical_indicators.bollinger_bands.middle.toFixed(2)}<br>
                                ä¸‹è½¨: $${coin.technical_indicators.bollinger_bands.lower.toFixed(2)}
                            </div>
                            
                            <div class="rsi-indicator">
                                <strong>RSI:</strong> ${coin.technical_indicators.rsi.value.toFixed(2)}
                                <span class="rsi-signal ${rsiSignalClass}">${rsiSignalText}</span>
                            </div>
                        </div>
                        
                        <div style="font-size: 0.8rem; color: #7f8c8d; margin-top: 10px;">
                            æ›´æ–°æ—¶é—´: ${this.formatTime(new Date(coin.updated_at))}
                        </div>
                    </div>
                `;
            }

            getRSISignalClass(signal) {
                switch (signal) {
                    case 'Overbought': return 'rsi-overbought';
                    case 'Oversold': return 'rsi-oversold';
                    default: return 'rsi-normal';
                }
            }

            getRSISignalText(signal) {
                switch (signal) {
                    case 'Overbought': return 'è¶…ä¹°';
                    case 'Oversold': return 'è¶…å–';
                    default: return 'æ­£å¸¸';
                }
            }

            formatLargeNumber(num) {
                if (num >= 1e12) return (num / 1e12).toFixed(1) + 'T';
                if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return num.toFixed(0);
            }

            formatTime(date) {
                return date.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            }

            updateConnectionStatus(connected) {
                const status = document.getElementById('connectionStatus');
                if (connected) {
                    status.textContent = 'ğŸŸ¢ å·²è¿æ¥';
                    status.className = 'connection-status connected';
                } else {
                    status.textContent = 'ğŸ”´ è¿æ¥æ–­å¼€';
                    status.className = 'connection-status disconnected';
                }
            }

            updateStats(stats) {
                const hitRate = stats.hits + stats.misses > 0 
                    ? ((stats.hits / (stats.hits + stats.misses)) * 100).toFixed(1) + '%'
                    : 'N/A';
                document.getElementById('cacheHits').textContent = hitRate;
            }

            updateFearGreedIndex(fearGreedData) {
                const fearGreedElement = document.getElementById('fearGreedIndex');
                
                if (fearGreedData && fearGreedData.value !== undefined) {
                    const value = fearGreedData.value;
                    const chineseClassification = fearGreedData.chinese_classification || fearGreedData.classification;
                    
                    // æ ¹æ®æŒ‡æ•°å€¼è®¾ç½®é¢œè‰²
                    let color = '#95a5a6'; // é»˜è®¤ç°è‰²
                    if (value <= 24) {
                        color = '#e74c3c'; // æåº¦ææƒ§ - çº¢è‰²
                    } else if (value <= 44) {
                        color = '#f39c12'; // ææƒ§ - æ©™è‰²
                    } else if (value <= 55) {
                        color = '#95a5a6'; // ä¸­æ€§ - ç°è‰²
                    } else if (value <= 75) {
                        color = '#f1c40f'; // è´ªå©ª - é»„è‰²
                    } else {
                        color = '#27ae60'; // æåº¦è´ªå©ª - ç»¿è‰²
                    }
                    
                    fearGreedElement.innerHTML = `
                        <span style="color: ${color}; font-weight: bold;">${value}</span>
                        <br>
                        <small style="color: ${color};">${chineseClassification}</small>
                    `;
                    
                    // æ·»åŠ å·¥å…·æç¤º
                    fearGreedElement.title = fearGreedData.investment_advice || 'å¸‚åœºæƒ…ç»ªæŒ‡æ ‡';
                } else {
                    fearGreedElement.textContent = '-';
                }
            }

            showError(message) {
                const container = document.getElementById('cryptoContainer');
                container.innerHTML = `<div class="error">âŒ ${message}</div>`;
            }

            initChart() {
                const ctx = document.getElementById('priceChart').getContext('2d');
                this.priceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: []
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: false,
                                title: {
                                    display: true,
                                    text: 'ä»·æ ¼ (USD)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'æ—¶é—´'
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'åŠ å¯†è´§å¸ä»·æ ¼è¶‹åŠ¿'
                            },
                            legend: {
                                display: true
                            }
                        }
                    }
                });
            }

            updateChart(cryptoData) {
                if (!this.priceChart) return;

                const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'];
                const datasets = [];

                cryptoData.slice(0, 5).forEach((coin, index) => { // åªæ˜¾ç¤ºå‰5ä¸ªå¸ç§
                    const history = this.priceHistory.get(coin.coin_id) || [];
                    if (history.length > 1) {
                        datasets.push({
                            label: coin.symbol.toUpperCase(),
                            data: history.map(h => h.price),
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '20',
                            tension: 0.1,
                            fill: false
                        });
                    }
                });

                // ä½¿ç”¨æœ€é•¿å†å²è®°å½•çš„æ—¶é—´æ ‡ç­¾
                let longestHistory = [];
                this.priceHistory.forEach(history => {
                    if (history.length > longestHistory.length) {
                        longestHistory = history;
                    }
                });

                this.priceChart.data.labels = longestHistory.map(h => 
                    h.time.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' })
                );
                this.priceChart.data.datasets = datasets;
                this.priceChart.update();
            }

            cleanupOldData() {
                const cutoffTime = new Date(Date.now() - 24 * 60 * 60 * 1000); // 24å°æ—¶å‰
                
                this.priceHistory.forEach((history, coinId) => {
                    const filteredHistory = history.filter(point => point.time > cutoffTime);
                    this.priceHistory.set(coinId, filteredHistory);
                });
            }
        }

        // å¯åŠ¨ä»ªè¡¨æ¿
        document.addEventListener('DOMContentLoaded', () => {
            new CryptoDashboard();
        });
    </script>
</body>
</html> 